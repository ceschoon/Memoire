#include <cmath>
#include <iostream>
#include <iomanip>
#include <fstream>
#include <complex>
#include <stdexcept>
#include <vector>
#include <time.h>

#include <mgl2/mgl.h>
#include <mgl2/fltk.h>

#ifdef USE_OMP
#include <omp.h>
#endif

using namespace std;

#define SMALL_DENSITY 1e-8

#include "Minimizer.h"

void DDFT::initialize()
{
  Minimizer::initialize();

  if(show_)
    {
      //      gr_ = new mglGraph;
      //      density_.initialize_2D_data(data_2D_);
    }

  F_ = dft_.calculateFreeEnergyAndDerivatives(density_, 0.0, dF_,true);   

  DFT_Vec dummy;
  F_ += dft_.F_IdealGas(density_, dummy);
  F_ += dft_.F_External(density_,0.0,dummy);

  
  cout << "Initial value of F = " << F_ << endl;
}


int DDFT::draw_before()
{
  /*
  if(!show_ || !gr_) return 0;

  //  density_.fill_2D_data(data_2D_);

  //clear the window
  gr_->Clf();	

  // basic window formating
  gr_->Box();  
  gr_->Alpha(false);
  gr_->SetRange('c', 0.0, 1.0);

  // set the color scheme
  //	  gr_->Dens(a,"kRryw");
  //	  gr_->Dens(a,"UbcyqR");
  gr_->Dens(data_2D_,"kBbcw");

  // Write a title
  char str[48];	
  snprintf(str,48,"calls = %d F = %lf N = %lf",calls_, F_, density_.getNumberAtoms());
  gr_->Puts(mglPoint(0,1.1),str);
  */
  return 0;
}

bool DDFT::sub_step_x(DFT_Vec &ynew, Density& density, DFT_Vec *tangent)
{
  double dx = density.getDX();
  double dy = density.getDY();
  double dz = density.getDZ();

  double Dx = dt_/(3*dx*dx);
  double Dy = dt_/(3*dy*dy);
  double Dz = dt_/(3*dz*dz);

  double dV = dx*dy*dz;

  bool bLessThanZero = false;

  /*
  try {
    calls_++;
    bool onlyFex = true;
    F_ = dft_.calculateFreeEnergyAndDerivatives(density,0.0, dF_,onlyFex);   
  } catch( Eta_Too_Large_Exception &e) {
    cout << "Here1" << endl;
    throw e;
  }
  */

  if(tangent) reverseForce(tangent);

  
  int chunk = density.Ny()/10;
  int iy;

#pragma omp parallel for			\
  shared(chunk,dx,dy,dz,Dx,Dy,Dz,dV)		\
  private(iy)					\
  schedule(static,chunk)			  
  for(iy = 0;iy<density.Ny();iy++)
    for(int iz = 0;iz<density.Nz();iz++)
      {
	// set up source term for tridiagonal equations
	DFT_Vec RHS(density.Nx());

	for(int ix=0;ix<density.Nx();ix++)
	  {
	    long i0 = density.get_PBC_Pos(ix,iy,iz);

	    long ipx = density.get_PBC_Pos(ix+1,iy,iz);
	    long imx = density.get_PBC_Pos(ix-1,iy,iz);

	    long ipy = density.get_PBC_Pos(ix,iy+1,iz);
	    long imy = density.get_PBC_Pos(ix,iy-1,iz);

	    long ipz = density.get_PBC_Pos(ix,iy,iz+1);
	    long imz = density.get_PBC_Pos(ix,iy,iz-1);
	    
	    double r0 = density.getDensity(i0);

	    double rpx = density.getDensity(ipx);
	    double rmx = density.getDensity(imx);

	    double rpy = density.getDensity(ipy);
	    double rmy = density.getDensity(imy);
	    
	    double rpz = density.getDensity(ipz);
	    double rmz = density.getDensity(imz);

	    double f0 = dF_.get(i0);

	    double fpx = dF_.get(ipx);
	    double fmx = dF_.get(imx);

	    double fpy = dF_.get(ipy);
	    double fmy = dF_.get(imy);

	    double fpz = dF_.get(ipz);
	    double fmz = dF_.get(imz);

	    double RHS_F = Dx*((rpx+r0)*(fpx-f0)-(r0+rmx)*(f0-fmx))
	      +Dy*((rpy+r0)*(fpy-f0)-(r0+rmy)*(f0-fmy))
	      +Dz*((rpz+r0)*(fpz-f0)-(r0+rmz)*(f0-fmz));

	    // factor 1/2 because of density average used in prev line
	    // factor dV because f0, etc carries a dV
	    RHS_F *= 1.0/(2*dV);

	    
	    // N.B. getFieldDeriv returns the derivative at iz-0.5.
	    int Nz = density.Nz();
	    double dvpz = density.getFieldDeriv(0,0,(iz+1 > Nz ? 0 : iz+1),2);
	    double dvmz = density.getFieldDeriv(0,0,iz,2);
	    RHS_F += dz*Dz*((rpz+r0)*dvpz-(r0+rmz)*dvmz)/2;
	    
	    RHS.set(ix, r0 + Dy*(rpy+rmy-2*r0) + Dz*(rpz+rmz-2*r0) + RHS_F);
	  }

	solv_periodic_tridiag(RHS,Dx);

	for(int ix=0;ix<density.Nx() && !bLessThanZero;ix++)
	  {
	    long i0 = density.get_PBC_Pos(ix,iy,iz);	

	    if(RHS.get(ix) > 0)
	      ynew.set(i0,RHS.get(ix));
	    else {
	      bLessThanZero = true;
	      //	      ynew.set(i0,SMALL_DENSITY); //density.getDensity(i0));
	      //	      cout << "Density less than zero in sub_step_x" << endl;
	      //	      throw std::runtime_error("Density less than zero in sub_step_x");	      
	    }
	  }
      }
  return bLessThanZero;
}


bool DDFT::sub_step_y(DFT_Vec &ynew, Density &density, DFT_Vec *tangent)
{
  double dx = density.getDX();
  double dy = density.getDY();
  double dz = density.getDZ();

  double Dx = dt_/(3*dx*dx);
  double Dy = dt_/(3*dy*dy);
  double Dz = dt_/(3*dz*dz);

  double dV = dx*dy*dz;

  bool bLessThanZero = false;
  
  try {
    calls_++;
    bool onlyFex = true;
    F_ = dft_.calculateFreeEnergyAndDerivatives(density,0.0, dF_,onlyFex);   
  } catch( Eta_Too_Large_Exception &e) {
    cout << "Here2" << endl;
    throw e;
  }

  if(tangent) reverseForce(tangent);

  int chunk = density.Nx()/10;
  int ix;

#pragma omp parallel for			\
  shared(chunk,dx,dy,dz,Dx,Dy,Dz,dV)		\
  private(ix)					\
  schedule(static,chunk)			  
  for(ix = 0;ix<density.Nx();ix++)
    for(int iz = 0;iz<density.Nz();iz++)
      {
	// set up source term for tridiagonal equations
	DFT_Vec RHS(density.Ny());

	for(int iy=0;iy<density.Ny();iy++)
	  {
	    long i0 = density.get_PBC_Pos(ix,iy,iz);

	    long ipx = density.get_PBC_Pos(ix+1,iy,iz);
	    long imx = density.get_PBC_Pos(ix-1,iy,iz);

	    long ipy = density.get_PBC_Pos(ix,iy+1,iz);
	    long imy = density.get_PBC_Pos(ix,iy-1,iz);

	    long ipz = density.get_PBC_Pos(ix,iy,iz+1);
	    long imz = density.get_PBC_Pos(ix,iy,iz-1);
	    
	    double r0 = density.getDensity(i0);

	    double rpx = density.getDensity(ipx);
	    double rmx = density.getDensity(imx);

	    double rpy = density.getDensity(ipy);
	    double rmy = density.getDensity(imy);
	    
	    double rpz = density.getDensity(ipz);
	    double rmz = density.getDensity(imz);

	    double f0 = dF_.get(i0);

	    double fpx = dF_.get(ipx);
	    double fmx = dF_.get(imx);

	    double fpy = dF_.get(ipy);
	    double fmy = dF_.get(imy);

	    double fpz = dF_.get(ipz);
	    double fmz = dF_.get(imz);

	    double RHS_F = Dx*((rpx+r0)*(fpx-f0)-(r0+rmx)*(f0-fmx))
	      +Dy*((rpy+r0)*(fpy-f0)-(r0+rmy)*(f0-fmy))
	      +Dz*((rpz+r0)*(fpz-f0)-(r0+rmz)*(f0-fmz));
	    
	    // factor 1/2 because of density average used in prev line
	    // factor dV because f0, etc carries a dV
	    RHS_F *= 1.0/(2*dV);
	    
	    // N.B. getFieldDeriv returns the derivative at iz-0.5.
	    int Nz = density.Nz();
	    double dvpz = density.getFieldDeriv(0,0,(iz+1 > Nz ? 0     : iz+1),2);
	    double dvmz = density.getFieldDeriv(0,0,iz,2);
	    RHS_F += dz*Dz*((rpz+r0)*dvpz-(r0+rmz)*dvmz)/2;	    

	    RHS.set(iy, r0 + Dx*(rpx+rmx-2*r0) + Dz*(rpz+rmz-2*r0) + RHS_F);
	  }

	solv_periodic_tridiag(RHS,Dy);

	for(int iy=0;iy<density.Ny() && !bLessThanZero;iy++)
	  {
	    long i0 = density.get_PBC_Pos(ix,iy,iz);	

	    if(RHS.get(iy) > 0)
	      ynew.set(i0,RHS.get(iy));
	    else {
	      bLessThanZero = true;	      
	      //	      ynew.set(i0,SMALL_DENSITY); //density.getDensity(i0));
	      //	      cout << "Density less than zero in sub_step_y" << endl;
	      //	      throw std::runtime_error("Density less than zero in sub_step_y");
	    }
	  }
      }
  return bLessThanZero;
}

bool DDFT::sub_step_z(DFT_Vec &ynew, Density &density, DFT_Vec *tangent)
{
  double dx = density.getDX();
  double dy = density.getDY();
  double dz = density.getDZ();

  double Dx = dt_/(3*dx*dx);
  double Dy = dt_/(3*dy*dy);
  double Dz = dt_/(3*dz*dz);

  double dV = dx*dy*dz;

  bool bLessThanZero = false;

  try {
    calls_++;
    bool onlyFex = true;
    F_ = dft_.calculateFreeEnergyAndDerivatives(density,0.0, dF_,onlyFex);   
  } catch( Eta_Too_Large_Exception &e) {
    cout << "Here3" << endl;
    throw e;
  }

  if(tangent) reverseForce(tangent);
    

  int chunk = density.Nx()/10;
  int ix;

#pragma omp parallel for			\
  shared(chunk,dx,dy,dz,Dx,Dy,Dz,dV)		\
  private(ix)					\
  schedule(static,chunk)			  
  for(ix = 0;ix<density.Nx();ix++)
    for(int iy = 0;iy<density.Ny();iy++)
      {
	// set up source term for tridiagonal equations
	DFT_Vec RHS(density.Nz());

	for(int iz=0;iz<density.Nz();iz++)
	  {
	    long i0 = density.get_PBC_Pos(ix,iy,iz);

	    long ipx = density.get_PBC_Pos(ix+1,iy,iz);
	    long imx = density.get_PBC_Pos(ix-1,iy,iz);
	    
	    long ipy = density.get_PBC_Pos(ix,iy+1,iz);
	    long imy = density.get_PBC_Pos(ix,iy-1,iz);

	    long ipz = density.get_PBC_Pos(ix,iy,iz+1);
	    long imz = density.get_PBC_Pos(ix,iy,iz-1);
	    
	    double r0 = density.getDensity(i0);

	    double rpx = density.getDensity(ipx);
	    double rmx = density.getDensity(imx);

	    double rpy = density.getDensity(ipy);
	    double rmy = density.getDensity(imy);

	    double rpz = density.getDensity(ipz);
	    double rmz = density.getDensity(imz);

	    double f0 = dF_.get(i0);

	    double fpx = dF_.get(ipx);
	    double fmx = dF_.get(imx);

	    double fpy = dF_.get(ipy);
	    double fmy = dF_.get(imy);

	    double fpz = dF_.get(ipz);
	    double fmz = dF_.get(imz);
	    
	    double RHS_F = Dx*((rpx+r0)*(fpx-f0)-(r0+rmx)*(f0-fmx))
	      +Dy*((rpy+r0)*(fpy-f0)-(r0+rmy)*(f0-fmy))
	      +Dz*((rpz+r0)*(fpz-f0)-(r0+rmz)*(f0-fmz));

	    // factor 1/2 because of density average used in prev line
	    // factor dV because f0, etc carries a dV
	    RHS_F *= 1.0/(2*dV);
	    
	    // N.B. getFieldDeriv returns the derivative at iz-0.5.
	    int Nz = density.Nz();
	    double dvpz = density.getFieldDeriv(0,0,(iz+1 > Nz ? 0     : iz+1),2);
	    double dvmz = density.getFieldDeriv(0,0,iz,2);
	    RHS_F += dz*Dz*((rpz+r0)*dvpz-(r0+rmz)*dvmz)/2;	    

	    RHS.set(iz, r0 + Dx*(rpx+rmx-2*r0) + Dy*(rpy+rmy-2*r0) + RHS_F);
	  }

	solv_periodic_tridiag(RHS,Dz);

	for(int iz=0;iz<density.Nz() && !bLessThanZero;iz++)
	  {
	    long i0 = density.get_PBC_Pos(ix,iy,iz);	

	    if(RHS.get(iz) > 0)
	      ynew.set(i0,RHS.get(iz));
	    else {
	      bLessThanZero = true;
	      //	      ynew.set(i0,SMALL_DENSITY); //density.getDensity(i0));
	      //	      cout << "Density less than zero in sub_step_z" << endl;
	      //throw std::runtime_error("Density less than zero in sub_step_z");	      
	    }
	  }
      }
  return bLessThanZero;
}

void DDFT::reverseForce(DFT_Vec *tangent) //;reverseForce(DFT_Vec *tangent)
{
  double prod = dF_.dotWith(*tangent);
  dF_.Increment_And_Scale(*tangent,-2*prod);
}


// Solve a tridiagonal system of the form
//       b[0] -D    0    0  0  0  0 ...  0    0    = RHS[0]
//       -D   b[1] -D    0  0  0  0 ...  0    0    = RHS[1]
//        0   -D   b[2] -D  0  0  0 ...  0    0    = RHS[2]
//                  ...
//        0   0     0    0  0  0  0 ... -D  b[N-1] = RHS[N-1]
//
//     The upper band is c[i] so that initially c[i] = -D for 0 <= i <= N-2
//     The lower band is a[i]
//     In the first pass, we eliminate the lower band
//              1    c[i-1] 0   ... = RHS[i-1]
//            a[i]   b[i]  c[i] ... = RHS[i]
// 
void DDFT::solv_tridiag(const DFT_Vec &b, DFT_Vec &RHS, double D)
{
  int N = RHS.size();
  
  DFT_Vec a(N); // lower
  DFT_Vec c(N); // upper

  for(int i=0;i<N;i++) {a.set(i,-D); c.set(i,-D);}

  // Scale the first line so that b[0] ==> 1
  c.scaleBy(0,b.get(0)); RHS.scaleBy(0,b.get(0));
  for(int i=1;i<N;i++)
    {
      double v = b.get(i)-a.get(i)*c.get(i-1);
      c.scaleBy(i,v);
      RHS.set(i,(RHS.get(i) - a.get(i)*RHS.get(i-1))/v);
    }
  for(int i=N-2;i>=0;i--)
    RHS.set(i, RHS.get(i) - c.get(i)*RHS.get(i+1));
}

// Solve a tridiagonal system of the form
//       b[0]  -D    0    0  0  0  0 ...  0   -D    = RHS[0]
//       -D    b[1] -D    0  0  0  0 ...  0    0    = RHS[1]
//        0    -D   b[2] -D  0  0  0 ...  0    0    = RHS[2]
//                  ...
//       -D    0     0    0  0  0  0 ... -D  b[N-1] = RHS[N-1]
//
//     The upper band is c[i] so that initially c[i] = -D for 0 <= i <= N-2
//     The lower band is a[i]
//     In the first pass, we eliminate the lower band
//              1    c[i-1] 0   ...  0  beta[i-1] = RHS[i-1]
//            a[i]   b[i]  c[i] ...  0     0      = RHS[i]
//                      ...
//             alpha  0    0    ... -D     b[N-1] = RHS[N-1]       
//
void DDFT::solv_periodic_tridiag_2(DFT_Vec &b, DFT_Vec &RHS, double D)
{
  int N = RHS.size();
  
  double a; // lower band - these values are all the same and never change
  DFT_Vec c(N); // upper
  DFT_Vec beta(N); // right-most column
  double alpha;

  for(int i=0;i<N;i++) c.set(i,-D);
  beta.zeros(N);
  a = alpha = -D;
  beta.set(0,-D);
  
  // Scale the first line so that b[0] ==> 1
  c.scaleBy(0,b.get(0)); beta.scaleBy(0,b.get(0)); RHS.scaleBy(0,b.get(0));
  for(int i=1;i<N;i++)
    {
      double v = b.get(i)-a*c.get(i-1);
      RHS.set(i,(RHS.get(i) - a*RHS.get(i-1))/v);
      if(i < N-2)
	{
	  c.scaleBy(i,v);
	  beta.set(i,-a*beta.get(i-1)/v);
	} else if(i == N-2) {
	c.set(  N-2, (  c.get(N-2) - a*beta.get(N-3))/v);
	beta.set(i,0.0);
      }

      // also get rid of alpha at position (N-1,i-1) and create a new one at (N-1,i)
      if(i < N-1)
	{
	  RHS.set(N-1, RHS.get(N-1) -alpha*RHS.get(i-1));
	  b.set(  N-1,   b.get(N-1) -alpha*beta.get(i-1));
	  alpha =                   -alpha*  c.get(i-1);
	} else alpha = 0.0;
      }
  for(int i=N-2;i>=0;i--)
    RHS.set(i, RHS.get(i) - c.get(i)*RHS.get(i+1) - beta.get(i)*RHS.get(N-1));
      
}



void DDFT::solv_periodic_tridiag(DFT_Vec &RHS, double D)
{
  int N = RHS.size();
  
  // modify entries
  double alpha = -D;
  double beta  = -D;
  double gamma = -1-2*D;

  DFT_Vec b(N); // diag

  for(int i=0;i<N;i++) b.set(i,1+2*D);

  b.addTo(0,-gamma);
  b.addTo(N-1,-alpha*beta/gamma);

  solv_tridiag(b,RHS,D);

  DFT_Vec u(N); u.zeros(N);

  u.set(0,gamma);
  u.set(N-1,alpha);

  solv_tridiag(b,u,D);

  double fact = (RHS.get(0)+beta*RHS.get(N-1)/gamma)/(1+u.get(0)+beta*u.get(N-1)/gamma);

  for(int i=0;i<N;i++) RHS.addTo(i, -fact*u.get(i)); 
}


int cc = 0;

double DDFT::step(DFT_Vec *tangent)
{
  DFT_Vec ystep(density_.Ntot());

  bool bLessThanZero;
  
  //  double dt = 0.1*density_.getDX() * density_.getDX();

  cout << "===================================================================================================================" << endl;
  bLessThanZero = sub_step_x(ystep,density_,tangent);
  density_.set(ystep);
  
  bLessThanZero =sub_step_y(ystep,density_,tangent);
  density_.set(ystep);

  bLessThanZero =sub_step_z(ystep,density_,tangent);
  density_.set(ystep);

  calls_++;

  cout << "bLessThanZero = " << bLessThanZero << endl;
  
  F_ = dft_.calculateFreeEnergyAndDerivatives(density_,0.0, dF_,true);  

  DFT_Vec dummy;
  F_ += dft_.F_IdealGas(density_,dummy);
  F_ += dft_.F_External(density_,0.0,dummy);

  
  if(grace_)
    {
      grace_->deleteDataSet(0);
      grace_->deleteDataSet(1);
      grace_->deleteDataSet(2);
      for(int i=0;i<density_.Nx();i++)
	grace_->addPoint(i,density_.getDensity(i,density_.Ny()/2, density_.Nz()/2),0);

      for(int i=0;i<density_.Ny();i++)
	grace_->addPoint(i,density_.getDensity(density_.Nx()/2,i, density_.Nz()/2),1);

      for(int i=0;i<density_.Nz();i++)
	grace_->addPoint(i,density_.getDensity(density_.Nx()/2,density_.Ny()/2,i),2);

      if(cc == 0)
	for(int i=0;i<density_.Nx();i++)
	  grace_->addPoint(i,density_.getDensity(i,density_.Ny()/2, density_.Nz()/2),3);

      cc = 1;
  
      grace_->redraw();
    }
  
  return F_;
}



double DDFT::step_string(double &dt, Density &temp_density, DFT_Vec *tangent)
{
  DFT_Vec ystep(temp_density.Ntot());

  DFT_Vec reset(temp_density.getDensity());

  dt_ = dt;
  
  double F = dft_.calculateFreeEnergyAndDerivatives(temp_density,0.0, dF_,true);

  bool bLessThanZero = false;
  do {
    bLessThanZero = sub_step_x(ystep,temp_density,tangent);
    
    if(!bLessThanZero) // x was OK, try y
      {
	temp_density.set(ystep);
	bLessThanZero = sub_step_y(ystep,temp_density,tangent);
	if(!bLessThanZero) // y was OK, try z
	  {
	    temp_density.set(ystep);
	    bLessThanZero = sub_step_z(ystep,temp_density,tangent);
	  }
      }
    
    if(bLessThanZero) // one of the updates failed
      {
	dt_ = (dt /= 2);
	temp_density.set(reset);
      } else temp_density.set(ystep); // final updae fo the density
  } while(bLessThanZero);
  
  F = dft_.calculateFreeEnergyAndDerivatives(temp_density,0.0, dF_,true);
  DFT_Vec dummy;
  F += dft_.F_IdealGas(temp_density,dummy);
  F += dft_.F_External(temp_density,0.0,dummy);

  return F;
}

double DDFT::F_string(Density &temp_density, double *fmax)
{
  DFT_Vec dummy;
  double F =  dft_.calculateFreeEnergyAndDerivatives(temp_density,0.0, dummy,false);

  if(fmax) *fmax = dummy.inf_norm()/temp_density.dV();;
  
  return F;
}
